@using Microsoft.AspNetCore.Components.Rendering
@using Microsoft.FluentUI.AspNetCore.Components.DataGrid.Infrastructure
@inherits FluentComponentBase
@typeparam TGridItem
<CascadingValue TValue="InternalGridContext<TGridItem>" IsFixed="true" Value="@_internalRfGridContext">
    @{
        StartCollectingColumns();
    }
    @if (!_manualGrid)
    {
        @ChildContent
    }
    <Defer>
        @{
            FinishCollectingColumns();
        }
        <ColumnsCollectedNotifier TGridItem="TGridItem" />
        <fluent-data-grid @ref=_gridReference
                          no-tabbing=@NoTabbing
                          generate-header="none"
                          grid-template-columns=@GridTemplateColumns
                          class="@GridClass()"
                          style="@Style"
                          aria-rowcount="@(_ariaBodyRowCount + 1)"
                          @onrowfocus=HandleOnRowFocus
                          @onclosecolumnoptions="CloseColumnOptions"
                          @attributes="AdditionalAttributes">
            @if (GenerateHeader != GenerateHeaderOption.None)
            {
                DataGridRowType headerType = DataGridRowType.Header;
                if (GenerateHeader == GenerateHeaderOption.Sticky)
                    headerType = DataGridRowType.StickyHeader;
                <FluentDataGridRow RowType=@headerType TGridItem=TGridItem>
                    @_renderColumnHeaders
                </FluentDataGridRow>
            }

            @if (_ariaBodyRowCount == 0 && !_manualGrid)
            {
                <div class="empty-content-row" role="row">
                    <div class="empty-content-cell" role="gridcell">
                        @if (EmptyContent is null)
                        {
                            @("No data to show!")
                            ;
                        }
                        else
                        {
                            @EmptyContent
                        }
                    </div>
                </div>
            }
            else
            {
                @if (Virtualize)
                {
                    <Virtualize @ref="@_virtualizeComponent"
                                TItem="(int RowIndex, TGridItem Data)"
                                ItemSize="@ItemSize"
                                ItemsProvider="@ProvideVirtualizedItems"
                                ItemContent="@(item => builder => RenderRow(builder, item.RowIndex, item.Data))"
                                Placeholder="@(placeholderContext => builder => RenderPlaceholderRow(builder, placeholderContext))" />
                    @if (IsLoading)
                    {
                        <div><span class="oi oi-reload spin"></span> Loading more items...</div>
                    }         
                    @_renderLastItem
                }
                else
                {
                    @_renderNonVirtualizedRows
                }
            }
            @if (_manualGrid)
            {
                @ChildContent
            }
        </fluent-data-grid>
    </Defer>
</CascadingValue>

@code {
    private void RenderNonVirtualizedRows(RenderTreeBuilder __builder)
    {
        var initialRowIndex = (GenerateHeader != GenerateHeaderOption.None) ? 2 : 1; // aria-rowindex is 1-based, plus 1 if there is a header
        var rowIndex = initialRowIndex;
        foreach (var item in _currentNonVirtualizedViewItems)
        {
            RenderRow(__builder, rowIndex++, item);
        }
    }

    private void RenderRow(RenderTreeBuilder __builder, int rowIndex, TGridItem item)
    {
        var rowClass = RowClass?.Invoke(item) ?? null;
        var rowStyle = RowStyle?.Invoke(item) ?? null;

        <FluentDataGridRow @key="@(ItemKey(item))" GridTemplateColumns=@GridTemplateColumns aria-rowindex="@rowIndex" Class="@rowClass" Style="@rowStyle" TGridItem="TGridItem" Item="@item">
            @for (var colIndex = 0; colIndex < _columns.Count; colIndex++)
            {
                var col = _columns[colIndex];

                string? tooltip = col.Tooltip ? @col.RawCellContent(item) : null;

                <FluentDataGridCell GridColumn=@(colIndex+1) Class="@ColumnClass(col)" Style="@col.Style" @key="@col" TGridItem="TGridItem" Item="@item" title="@tooltip" aria-label="@tooltip">
                    @((RenderFragment)(__builder => col.CellContent(__builder, item)))
                </FluentDataGridCell>
            }
        </FluentDataGridRow>
    }

    private void RenderPlaceholderRow(RenderTreeBuilder __builder, PlaceholderContext placeholderContext)
    {
        string? _rowsDataSize = $"height: {ItemSize}px";

        <FluentDataGridRow GridTemplateColumns=@GridTemplateColumns aria-rowindex="@(placeholderContext.Index + 1)" Style="@_rowsDataSize" TGridItem="TGridItem">
            @for (var colIndex = 0; colIndex < _columns.Count; colIndex++)
            {
                var col = _columns[colIndex];

                <FluentDataGridCell Class="@("grid-cell-placeholder " + @ColumnClass(col))" Style="@col.Style" @key="@col" GridColumn=@(colIndex+1) TGridItem="TGridItem">
                    @((RenderFragment)(__builder => col.RenderPlaceholderContent(__builder, placeholderContext)))
                </FluentDataGridCell>
            }
        </FluentDataGridRow>
    }


    private void RenderColumnHeaders(RenderTreeBuilder __builder)
    {
        @for (var colIndex = 0; colIndex < _columns.Count; colIndex++)
        {
            var col = _columns[colIndex];
            string CellId = Identifier.NewId();
            if (_sortByColumn == col)
                col.ShowSortIcon = true;
            else
                col.ShowSortIcon = false;

            <FluentDataGridCell GridColumn=@(colIndex+1) CellType=DataGridCellType.ColumnHeader Class="@("column-header " + @ColumnHeaderClass(col))" Style="@col.Style" aria-sort="@AriaSortValue(col)" @key="@col" scope="col" TGridItem="TGridItem">
                @col.HeaderContent
                @if (col == _displayOptionsForColumn)
                {
                    <div class="col-options">@col.ColumnOptions</div>
                }
                @if (ResizableColumns)
                {
                    <FluentDivider class="col-width-draghandle" Orientation="Orientation.Vertical" Role="DividerRole.Separator" />
                }
            </FluentDataGridCell>
        }
    }
    
    
    private ElementReference _lastItemIndicator;
    private RenderFragment _renderLastItem;
    private DotNetObjectReference<RfDataGrid<TGridItem>> _currentComponentReference;
    private IJSObjectReference? _module;
    private IJSObjectReference? _instance;
    private bool _enumerationCompleted;
    private CancellationTokenSource? _loadItemsCts;
    private InfiniteScrollingItemsProviderRequestDelegate<TGridItem>? _itemsProvider;
    private bool IsLoading => _loadItemsCts != null;
    [Parameter]
    public string LastItemIndicatorElement { get; set; } = "div";
    [JSInvokable]
    public async Task LoadMoreItems()
    {
        if (_loadItemsCts != null)
            return;

        if (ItemsProvider == null)
            return;

        var items = Items;
        var cts = new CancellationTokenSource();
        _loadItemsCts = cts;
        try
        {
            StateHasChanged(); // Allow the UI to display the loading indicator
            try
            {
                var length = items?.Count() ?? 0;
                var result = await ItemsProvider(new(
                    length, Pagination?.ItemsPerPage, _sortByColumn, _sortByAscending, cts.Token));
                if (!cts.IsCancellationRequested)
                {
                    items = items?.Concat(result.Items);

                    if (items?.Count() == length)
                    {
                        _enumerationCompleted = true;
                    }
                    else
                    {
                        System.Diagnostics.Debug.Assert(_instance != null);
                        await _instance.InvokeVoidAsync("onNewItems");
                    }
                }
            }
            catch (OperationCanceledException oce) when (oce.CancellationToken == cts.Token)
            {
                // No-op; we canceled the operation, so it's fine to suppress this exception.
            }
        }
        finally
        {
            _loadItemsCts = null;
            cts.Dispose();
        }

        StateHasChanged(); // Display the new items and hide the loading indicator
    }

   
    public async Task RefreshLazyDataAsync()
    {
        _loadItemsCts?.Cancel(); // Will be disposed by the LoadMoreData method
        _loadItemsCts = null;

        Items = new List<TGridItem>().AsQueryable();
        _enumerationCompleted = false;
        await LoadMoreItems();
    }
    private void RenderLastElement(RenderTreeBuilder __builder)
    {
        // This is the last element, so let's use a huge value
        __builder.OpenElement(1000, LastItemIndicatorElement);
        var style = _enumerationCompleted ? "height:0;width:0" : "height:1px;width:1px;flex-shrink:0";
        __builder.AddAttribute(1001, "style", style);
        __builder.AddElementReferenceCapture(1002, element => _lastItemIndicator = element);
        __builder.CloseElement();
    }
}
